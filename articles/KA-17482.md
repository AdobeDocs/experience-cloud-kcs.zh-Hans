---
title: "分析内存问题"
description: 描述
solution: Experience Manager
product: Experience Manager
applies-to: "Experience Manager"
keywords: "KCS"
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Roxann McGlumphy
article-created-date: "10/21/2021 5:18:56 PM"
article-published-by: Roxann McGlumphy
article-published-date: "10/21/2021 5:21:24 PM"
version-number: 1
article-number: KA-17482
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=ef6bccf5-9232-ec11-b6e5-000d3a5ba97a"
exl-id: 48e49bcc-3d49-464e-8af9-e4292b1d6899
source-git-commit: 0c3e421beca46d9fe1952b1f98538a50697216a0
workflow-type: tm+mt
source-wordcount: '866'
ht-degree: 1%

---

# 分析内存问题

## 描述

<br>症状<br><br>
的 [!DNL Java] 应用程序运行速度较慢，最终内存不足，或者在日志或控制台输出中看到错误 `OutOfMemoryError: Java heap space` 或 `OutOfMemoryError: gc overhead limit exceeded`.
<br><br>原因<br><br>
这些问题可能有多种原因。

一个可能的原因是 [!DNL Java] 在本例中，应用程序是从命令行启动的，该命令行具有的默认堆内存设置为 [!DNL Java]. 这表示jvm参数 `-Xmx` 未指定。 CRX或CQ需要至少256 MB的堆才能运行。 如果出现此问题，请从命令行开始，确保设置堆内存设置。 示例：


```
java -Xmx512m -jar *.jar
```


如果情况并非如此，则您的应用程序可能会保留太多对象，而不会释放这些对象以用于垃圾收集。 这叫内存泄漏，请参阅 [此处](http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html) 以了解更多信息。 请参阅下面关于如何分析java应用程序中内存问题的部分。


## 分辨率

创建堆转储<br><br>自动生成堆转储<br><br>
要在内存不足时自动创建堆转储，可添加jvm参数 `-XX:+HeapDumpOnOutOfMemoryError` 当应用程序引发堆转储时，自动生成堆转储 `OutOfMemoryError`. 例如，


```
java -Xmx256m -XX:+HeapDumpOnOutOfMemoryError -jar *.jar
```


这会生成堆转储文件(`java_...hprof`) `java` 进程内存不足。 在生成堆转储后，该进程可以继续运行。 通常，一个堆转储文件就足以分析问题。

<b>注意：</b> 如果您使用 `crx-quickstart/server/start` 脚本来启动CRX实例，然后您可以添加 `-XX:+HeapDumpOnOutOfMemoryError` 到 `CQ_JVM_OPTS` 变量（确保变量未添加注释）。 例如：


```
CQ_JVM_OPTS='-XX:+HeapDumpOnOutOfMemoryError'
```


添加此参数并重新启动CRX实例后，确认已设置新jvm选项。 运行 `ps -ef | grep java` 命令行。 然后检查您是否看到 `-XX:+HeapDumpOnOutOfMemoryError` 作为CRX的参数 `java` 进程。

如果由于磁盘空间限制而需要指定其他目录以在中生成堆转储，则可以添加 `-XX:HeapDumpPath=/path/to/generate/heapdump` 参数来告知jvm将文件放置到何处。

请参阅 [此处](http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions) ，以获取调试相关jvm参数的参考。
<br><br>手动生成堆转储<br><br>
<b>[!DNL Sun]/OracleJVM</b>

要手动生成堆转储，请运行此命令(jmap和jps可在 `bin` jdk主目录的文件夹):

1. 查一下 `java` 为生成堆转储的进程。
   - 在 [!DNL Unix] 或 [!DNL Linux] 这可以通过 `ps -ef | grep java` 或 `jps -l`
   - 在 [!DNL Windows] 打开任务管理器，按 `Ctrl+Shift+Esc` 然后转到 <b>查看</b> = <b>选择列</b> = <b>PID（进程标识符）</b> 或 `jps -l`
2. 运行下面的jmap命令，替换 `/path/to/generate/heapdumpfile.hprof` 使用要生成堆转储文件的位置，并替换 `1234` 上一步中查找的pid。

   ```
   jmap -dump:format=b,file=/path/to/generate/heapdumpfile.hprof 1234
   ```


<b>IBM JVM</b>

您首先必须更改有关转储代理的默认JVM设置，才能生成用户信号的正确转储。 存在多种类型的转储，但通常需要满 <b>系统转储</b> 进行彻底的内存分析。 添加以下参数：

<b>Xdump:heap:opts=PHD+CLASSIC:events=user -Xdump:system:events=user</b>

当JVM收到SIGQUIT([!DNL Linux]、AIX®、z/OS®和i5/OS™)或SIGBREAK([!DNL Windows])来自操作系统的信号。

有关详细信息，请参阅供应商的文档 [此处](http://pic.dhe.ibm.com/infocenter/java7sdk/v7r0/index.jsp?topic=%2Fcom.ibm.java.aix.70.doc%2Fdiag%2Fpreface%2Fchanges_70%2Foverview_gc.html).

<b>警告：</b> 堆转储文件较大，并且在磁盘上的大小可以与最大堆大小相同 `-Xmx` jvm参数配置。 确保为生成转储文件的目录分配了足够的磁盘空间。
<br><br>分析堆转储<br><br>
分析堆转储的一个好工具是 [!DNL Eclipse] MAT([!DNL Eclipse Memory Analyzer]): [http://www.eclipse.org/mat/](http://www.eclipse.org/mat/)

此工具无法分析 <b>IBM JVM</b> 生成的转储。 对于这些，有几种可能性。 [IBM HeapAnalyzer](https://www.ibm.com/developerworks/community/groups/service/html/communityview?communityUuid=4544bafe-c7a2-455f-9d43-eb866ea60091) 对于PHD或经典格式的堆转储将非常有用。

要获取完整的系统转储分析，请使用 [IBM支持助手工作台](http://www-01.ibm.com/software/support/isa/) ，使用 [IBM Monitoring and Diagnostic Tools for Java - Memory Analyzer 1.2版](http://www.ibm.com/developerworks/java/jdk/tools/memoryanalyzer/) 安装在顶部。
<br><br>堆直方图<br><br>
堆直方图是对每次使用的实时对象和内存数量的简单测量 [!DNL Java] 类。 很遗憾，根据 [!DNL Java] 安装时，所需的工具可能不可用，或者可能不总能正常工作。 要创建堆直方图，您首先需要的进程ID是 [!DNL Java] 进程。 要得到它，请跑 `ps` 或（如果可用），运行：


```
jps -l
```


此 [!DNL Java] 工具获取所有正在运行的进程id [!DNL Java] 进程。 示例：


```
327 
3332 sun.tools.jps.Jps
3313 crx-quickstart-....jar
```


现在，运行以下命令：


```
jmap -histo 3313
```


列表按所需总内存排序(浅：排除引用对象)。 前20行的输出最有趣。 示例输出：


```
JVM version is 1.5.0_20-141
Iterating over heap. This may take a while...
Warning: skipping invalid TLAB for thread t@62211
Warning: skipping invalid TLAB for thread t@62467
...
SizeCountClass description
-------------------------------------------------------
1059290412916byte
1028584075255* ConstMethodKlass
628317658388char
604230414928int
4995752116201* SymbolKlass
422089675255* MethodKlass
41965126969* ConstantPoolKlass
29285606969* InstanceKlassKlass
26310086066* ConstantPoolCacheKlass
2395872149742org.apache.jackrabbit.core.query.lucene.DocId$PlainDocId
14760087003java.util.HashMap$Entry
139612858172java.lang.String
107023244593java.util.HashMap$Entry
75398410036short
73546454org.apache.jackrabbit.core.query.lucene.DocId
7201927502java.lang.Class
64070413348com.day.crx.persistence.tar.index.IndexEntry
...
```


<b>其他信息</b>

为了帮助分析问题，我们还需要了解以下信息：

- CRX或CQ版本，包括所有已安装热修复程序版本号的列表。
- 操作系统、JVM供应商和版本。


<b>引用</b>

1 [http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html](http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html)
2 [http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions](http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions)
