---
title: “分析内存问题”
description: 描述
solution: Experience Manager
product: Experience Manager
applies-to: "Experience Manager"
keywords: “KCS”
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Roxann McGlumphy
article-created-date: "10/21/2021 5:18:56 PM"
article-published-by: Roxann McGlumphy
article-published-date: "10/21/2021 5:21:24 PM"
version-number: 1
article-number: KA-17482
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=ef6bccf5-9232-ec11-b6e5-000d3a5ba97a"
exl-id: 48e49bcc-3d49-464e-8af9-e4292b1d6899
source-git-commit: 0c3e421beca46d9fe1952b1f98538a50697216a0
workflow-type: ht
source-wordcount: '866'
ht-degree: 100%

---

# 分析内存问题

## 描述

<br>症状<br><br>
[!DNL Java] 应用程序运行速度较慢并最终耗尽内存，或者您在日志或控制台输出中看到错误 `OutOfMemoryError: Java heap space` 或者 `OutOfMemoryError: gc overhead limit exceeded`。
<br><br>原因<br><br>
此类问题可能有很多原因。

一个可能的原因是 [!DNL Java] 应用程序，在我们的例子中，CRX / CQ 是从命令行启动的，默认堆内存设置为 [!DNL Java]。这意味着 jvm 参数 `-Xmx` 未指定。 CRX 或 CQ 至少需要分配 256 MB 的堆才能运行。 如果这是问题所在，则从命令行开始，请确保设置了堆内存设置。 示例：


```
java -Xmx512m -jar *.jar
```


如果不是这种情况，那么您的应用程序可能会保留太多对象而没有为垃圾收集释放它们。这称为内存泄漏，请参阅[此处](http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html)了解更多信息。请参阅下面有关如何分析 Java 应用程序中的内存问题的部分。


## 分辨率

创建堆转储<br><br>自动生成堆转储<br><br>
要在内存不足时自动创建堆转储，可以添加 jvm 参数 `-XX:+HeapDumpOnOutOfMemoryError`，在应用程序抛出异常时自动生成堆转储 `OutOfMemoryError`。例如，


```
java -Xmx256m -XX:+HeapDumpOnOutOfMemoryError -jar *.jar
```


只要 `java` 进程内存不足，就会在进程的工作目录中生成堆转储文件 (`java_...hprof`)。生成堆转储后，该进程可以继续运行。通常，一个堆转储文件就足以分析问题。

<b>注意：</b>如果您正在使用 `crx-quickstart/server/start` 脚本来启动 CRX 实例，则您可以添加 `-XX:+HeapDumpOnOutOfMemoryError` 到 `CQ_JVM_OPTS` 变量（确保变量也未注释）。例如：


```
CQ_JVM_OPTS='-XX:+HeapDumpOnOutOfMemoryError'
```


添加此参数并重新启动 CRX 实例后，验证是否设置了新的 jvm 选项。 从命令行运行 `ps -ef | grep java`。 然后检查您是否看到 `-XX:+HeapDumpOnOutOfMemoryError` 作为 CRX `java` 进程的参数。

如果由于磁盘空间限制需要指定不同的目录来生成堆转储，则可以添加 `-XX:HeapDumpPath=/path/to/generate/heapdump` 参数告诉 jvm 文件的放置位置。

请参阅[此处](http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions)，了解有关调试相关 jvm 参数的引用。
<br><br>手动生成堆转储<br><br>
<b>[!DNL Sun]/Oracle JVM</b>

要手动生成堆转储，请运行此命令（jmap 和 jps 可见于 jdk 主目录下的 `bin` 文件夹）：

1. 查找您正在为其生成堆转储的 `java` 进程的 pid。
   - 在 [!DNL Unix] 或者 [!DNL Linux] 中，这可以用 `ps -ef | grep java` 或者 `jps -l` 完成
   - 在 [!DNL Windows] 中，这可以通过打开任务管理器来完成，按 `Ctrl+Shift+Esc` 键，然后前往<b>视图</b> = <b>选择列</b> = <b>PID（进程标识符）</b>或者 `jps -l`
2. 运行下面的 jmap 命令，使用您要生成堆转储文件的位置替换 `/path/to/generate/heapdumpfile.hprof`，然后使用您在上一步中查找的 pid 替换 `1234`。

   ```
   jmap -dump:format=b,file=/path/to/generate/heapdumpfile.hprof 1234
   ```


<b>IBM JVM</b>

您首先必须更改有关转储代理的默认 JVM 设置，以便在用户信号上生成正确的转储。 有几种转储，但您通常需要完整的转储<b>系统转储</b>进行彻底的内存分析。添加以下参数：

<b>Xdump:heap:opts=PHD+CLASSIC:events=user -Xdump:system:events=user</b>

当 JVM 收到来自操作系统的 SIGQUIT ([!DNL Linux]、AIX®、z/OS® 和 i5/OS™）或 SIGBREAK ([!DNL Windows]) 信号时，该“用户”事件会发生。

有关详细信息，请在[此处](http://pic.dhe.ibm.com/infocenter/java7sdk/v7r0/index.jsp?topic=%2Fcom.ibm.java.aix.70.doc%2Fdiag%2Fpreface%2Fchanges_70%2Foverview_gc.html)参阅供应商的文档。

<b>警告：</b>堆转储文件很大，在磁盘上的大小可以与最大堆 `-Xmx` jvm 参数配置相同。 确保您有足够的磁盘空间分配给生成转储文件的目录。
<br><br>分析堆转储<br><br>
分析堆转储的好工具是 [!DNL Eclipse] MAT ([!DNL Eclipse Memory Analyzer])：[http://www.eclipse.org/mat/](http://www.eclipse.org/mat/)

此工具无法分析 <b>IBM JVM</b> 生成的转储。 对于以上问题，有几种可能性。[IBM HeapAnalyzer](https://www.ibm.com/developerworks/community/groups/service/html/communityview?communityUuid=4544bafe-c7a2-455f-9d43-eb866ea60091) 将适用于 PHD 或经典格式的堆转储。

要进行完整的系统转储分析，请使用 [IBM 支持助理工作台](http://www-01.ibm.com/software/support/isa/)和 [IBM Java 的监控和诊断工具 – 内存分析器版本 1.2](http://www.ibm.com/developerworks/java/jdk/tools/memoryanalyzer/)安装在顶部。
<br><br>堆直方图<br><br>
堆直方图是根据 [!DNL Java] 类对每个使用的活动对象和内存数量的简单测量。 遗憾地是，所需的工具取决于 [!DNL Java] 安装，可能不可用或可能并不总是有效。要创建堆直方图，您首先需要 [!DNL Java] 进程的进程 ID。 要得到该 ID，请运行 `ps` 或（如果可用），运行：


```
jps -l
```


该 [!DNL Java] 工具获取所有正在运行的 [!DNL Java] 进程 ID。 示例：


```
327 
3332 sun.tools.jps.Jps
3313 crx-quickstart-....jar
```


现在，请运行以下命令：


```
jmap -histo 3313
```


该列表按所需的总内存排序（简略：不包括引用的对象）。输出的前 20 行是最有趣的。 输出示例：


```
JVM version is 1.5.0_20-141
Iterating over heap. This may take a while...
Warning: skipping invalid TLAB for thread t@62211
Warning: skipping invalid TLAB for thread t@62467
...
SizeCountClass description
-------------------------------------------------------
1059290412916byte
1028584075255* ConstMethodKlass
628317658388char
604230414928int
4995752116201* SymbolKlass
422089675255* MethodKlass
41965126969* ConstantPoolKlass
29285606969* InstanceKlassKlass
26310086066* ConstantPoolCacheKlass
2395872149742org.apache.jackrabbit.core.query.lucene.DocId$PlainDocId
14760087003java.util.HashMap$Entry
139612858172java.lang.String
107023244593java.util.HashMap$Entry
75398410036short
73546454org.apache.jackrabbit.core.query.lucene.DocId
7201927502java.lang.Class
64070413348com.day.crx.persistence.tar.index.IndexEntry
...
```


<b>其他信息</b>

为了帮助分析问题，我们还需要了解以下信息：

- CRX 或 CQ 版本，包括所有已安装修补程序版本号的列表。
- 操作系统版本、JVM 供应商和版本。


<b>引用</b>

1 [http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html](http://java.sun.com/javase/6/webnotes/trouble/TSG-VM/html/memleaks.html)
2 [http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions](http://java.sun.com/javase/technologies/hotspot/vmoptions.jsp#DebuggingOptions)
