---
title: Campaign Classic- [!UICONTROL 增量查询] 选择所有记录，而不是仅选择新记录
description: 描述
solution: Campaign
product: Campaign
applies-to: Campaign Classic
keywords: KCS
resolution: Resolution
internal-notes: Ticket = TK197178
bug: true
article-created-by: Marta Zator
article-created-date: 5/10/2022 9:47:14 AM
article-published-by: Marta Zator
article-published-date: 5/10/2022 9:51:21 AM
version-number: 2
article-number: KA-15190
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=ad8bd527-46d0-ec11-a7b5-00224809c101
exl-id: f3dee0a7-8047-4949-9162-de95ba07fa7f
source-git-commit: dc1937169029c76dbce1ba513dd6430dffbc86c5
workflow-type: tm+mt
source-wordcount: '516'
ht-degree: 0%

---

# Campaign Classic- [!UICONTROL 增量查询] 选择所有记录，而不是仅选择新记录

## 描述

客户有多个增量查询，但这些查询无法按预期运行。 他们不是仅提取自上次运行以来的新记录，而是每次都提取所有记录 — 就像正常情况一样 [!UICONTROL 查询] 活动。

## 解决方法

罪魁祸首是 [!UICONTROL Cleanup] 工作流。

此 [!UICONTROL 增量查询] 工作流的工作方式如下：

1. 维护包含先前迭代结果的历史记录表。
1. 获取目标查询中的所有行。
1. 筛选出历史记录表中存在的所有行
1. 将剩余结果添加到历史记录表中以进行下一个迭代筛选。

因此，此历史记录工作表名称具有以下表示法：

*wkfhistoworkflowid* activityName_

现在，对于workflowIDs 0 (对于将 `xtknewid` 允许负序列)，我们看到它实际上是：

*wkfhisto(uint)workflowid* activityName_

但这适用于工作流执行。

例如，增量活动 `incremental1` /workflow ID=-1将创建一个表 `wkfhisto4294967295_incremental1`.

我们忽略的是 [!UICONTROL Cleanup] 工作流。

在本例中，我们有一个代码尝试删除已删除工作流的工作表。

此处的专用代码列出了所有wkfhisto\*表，从它们的名称中提取workflowId（根据上述约定），并删除除在xtkworkflow表中找到其worklowID之外的所有其他表。

但是，它忽略了 `uint` 部分。

因此，它会尝试查找ID为4294967295的工作流，而不是将此代码转换为int。 由于未找到此工作流，因此将删除此表。 下次运行此工作流时， [!UICONTROL 增量查询] 活动找不到现有的历史记录表，并创建它将其视为首次运行。

<b>修复：</b>

Adobe Campaign Classic 20.1.1版本（内部版本9122及更高版本）中提供了此问题的修复。

<b>客户可以使用的解决方法：</b>

解决方法1：停止清理工作流并间歇性地运行该工作流以清理数据库和HDD，直到修复完成并可用。 如果您没有计划的升级，则不推荐。

解决方法2：假设 [!UICONTROL 增量查询] 活动会受到影响，请通过执行与 [!UICONTROL 增量查询] 通过创建用于保存历史记录表内容的持久性模式来执行。 使用以下项的组合 [!UICONTROL 查询] 和 [!UICONTROL 更新数据] 活动来模拟行为。 对于需要增量查询的所有工作流，需要执行此操作。

解决方法3：假设 [!UICONTROL 增量查询] 活动会受到影响，请通过向有问题的架构添加审核字段(tsCreated/tsLastModified)来解决此问题。 然后，您的增量查询将转换为带有where子句(如 `tscreated GetDate()`.

解决方法4：

- 创建一个新的序列xtknewworkflowid，并将其初始化为远离当前workflowId范围的某个值。
- 更改xtkworkflow架构以使用它 `pkSequence`
- 要求客户克隆所有受影响的工作流并删除原始工作流。
- 客户准备好升级后，请通过还原到 `xtknewId` 用于创建工作流（以避免意外的情况）。
