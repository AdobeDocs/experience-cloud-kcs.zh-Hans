---
title: “增量查询会选取所有记录，而不是仅选取新记录”
description: 描述
solution: Campaign
product: Campaign
applies-to: "Campaign Classic"
keywords: "KCS"
resolution: Resolution
internal-notes: "Ticket = TK197178"
bug: true
article-created-by: Tanay Sharma .
article-created-date: "9/26/2022 10:11:48 AM"
article-published-by: Tanay Sharma .
article-published-date: "9/26/2022 11:03:23 AM"
version-number: 3
article-number: KA-15190
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=e647789f-833d-ed11-9db1-002248086735"
source-git-commit: c07227262cb059b09254e8e1ec01542d4de2a881
workflow-type: tm+mt
source-wordcount: '353'
ht-degree: 0%

---

# “增量查询”会选取所有记录，而不是仅选取新记录

## 描述

<b>环境</b>
Campaign Classic


<b>问题/症状</b>
增量查询无法按预期工作。 他们不仅从上次运行后提取新记录，而是像普通查询活动一样，每次提取所有记录。


## 分辨率


此问题已在Adobe Campaign Classic 20.1.1版本（版本9122及更高版本）中修复。

<b>客户可以使用的解决方法：</b>

<b>解决方法1</b>:停止清理工作流并间歇性地运行它以清理数据库和硬盘，直到进行和可用修复。 如果您没有计划进行升级，则不建议您执行此操作。

<b>解决方法2</b>:假设增量查询活动受到影响。 与增量查询执行的操作相同，方法是创建用于保存历史记录表内容的永久架构。 使用查询和更新数据活动的组合来模拟行为。 对于所有需要增量查询的工作流，都需要执行此操作。

<b>解决方法3</b>:  假设增量查询活动受到影响。 通过添加审核字段来解决此问题 `tsCreated/tsLastModified` 到相关模式。 随后，您的增量查询将转换为具有where子句(如&#39;tscreated GetDate()&#39;)的普通查询活动。

<b>解决方法4</b>:

1. 创建新序列 `xtknewworkflowid` 并将其初始化到远离当前workflowId范围的位置。
2. 更改 `xtkworkflow` 使用此模式的架构 `pkSequence`.
3. 要求客户克隆所有受影响的工作流并删除原始工作流。
4. 客户准备好进行升级后，通过还原到 `xtknewId` （以避免意外的意外）。

<b>原因</b>
罪魁祸首是清理工作流。

增量查询工作流的工作方式如下：

1. 维护包含先前迭代结果的历史记录表。
2. 从目标查询中提取所有行。
3. 过滤掉历史记录表中存在的所有行
4. 将剩余结果添加到历史记录表中，以便进行下一次迭代筛选。


因此，该历史工作表名称的表示法如下：
`wkfhistoworkflowid` `activityName_`

现在，对于workflowIDs 0(对于 `xtknewid` 允许负序列)，我们看到它实际上是：

`wkfhisto(uint)workflowid``activityName_`

`Although this is okay for workflow execution.`

`So, for example, the incremental activity incremental1 of workflow ID=-1 will create a table wkfhisto4294967295_incremental1`.&#39;

`The thing which is missed is the CleanUp workflow.`

`Here, we have a code that tries to delete worktables of deleted workflows.`

`A dedicated code here lists all the wkfhisto tables, extracts the workflowId from their names (from the above convention), and deletes them all except the ones whose worklowIDs are found in the xtkworkflow table.`

`However, it misses the uint part.`

`So, it tries to look up a workflow with ID 4294967295 instead of casting this back to int. Since this workflow is not found, this table is deleted. Next time, when this workflow runs, the incremental query activity does not find an existing history table and creates it thinking of this as the first run ever.`
