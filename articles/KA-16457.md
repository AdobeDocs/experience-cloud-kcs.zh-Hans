---
title: "SegmentNotFoundException和IllegalArgumentException"
description: 描述
solution: Experience Manager
product: Experience Manager
applies-to: "Experience Manager"
keywords: "KCS"
resolution: Resolution
internal-notes: "Helpx Link: https://helpx.adobe.com/experience-manager/kb/offline-compaction-fails-with-SegmentNotFoundException-and-IllegalArgumentException.html"
bug: false
article-created-by: Emily Geary
article-created-date: "4/12/2021 6:09:12 PM"
article-published-by: Emily Geary
article-published-date: "4/12/2021 6:09:50 PM"
version-number: 7
article-number: KA-16457
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=7ed24a2d-ba9b-eb11-b1ac-000d3a3680d8"
exl-id: 54f6bac4-f81b-4685-89e6-eaedf60f3552
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '956'
ht-degree: 0%

---

# SegmentNotFoundException和IllegalArgumentException

## 描述


当存储库存在完整性问题时，运行离线压缩可能会因SegmentNotFoundException而失败。

您在AEM日志文件中观察到SegmentNotFoundException ，并且AEM无法按预期工作

或者

当存储库存在完整性问题时，运行离线压缩可能会因SegmentNotFoundException而失败。 日志中可以找到与下面类似的堆栈跟踪：

`13:51:21.523 main ERROR o.a.j.o.p.segment.SegmentTracker - Segment not found: 4d139bc4-150c-4f0a-b82a-40a4e519fe8a. Creation ` `date` `delta is 4 ms.`

`org.apache.jackrabbit.oak.plugins.segment.SegmentNotFoundException: Segment 4d139bc4-150c-4f0a-b82a-40a4e519fe8a not found`

`at org.apache.jackrabbit.oak.plugins.segment.` `file` `.FileStore.readSegment(FileStore.java:855) oak-run-1.0.22.jar:1.0.22`

`at org.apache.jackrabbit.oak.plugins.segment.SegmentTracker.getSegment(SegmentTracker.java:134)  oak-run-1.0.22.jar:1.0.22`

`at org.apache.jackrabbit.oak.plugins.segment.SegmentId.getSegment(SegmentId.java:101) oak-run-1.0.22.jar:1.0.22`

`...`

`Exception ` `in` `thread ` `"main"` `org.apache.jackrabbit.oak.plugins.segment.SegmentNotFoundException: Segment 4d139bc4-150c-4f0a-b82a-40a4e519fe8a not found`

`at org.apache.jackrabbit.oak.plugins.segment.` `file` `.FileStore.readSegment(FileStore.java:855)`

`at org.apache.jackrabbit.oak.plugins.segment.SegmentTracker.getSegment(SegmentTracker.java:134)`

`at org.apache.jackrabbit.oak.plugins.segment.SegmentId.getSegment(SegmentId.java:101)`

`...`

或者

如果存储库存在完整性问题，则运行离线压缩可能会失败，并出现IllegalArgument异常。 日志中可以找到与下面类似的堆栈跟踪：


| `java.lang.IllegalArgumentException`<br><br>`at com.google.common.base.Preconditions.checkArgument(Preconditions.java:77)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.ListRecord.(ListRecord.java:41)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.ListRecord.getEntry(ListRecord.java:64)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.ListRecord.getEntries(ListRecord.java:81)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.SegmentStream.` `read` `(SegmentStream.java:153)`<br><br>`at org.apache.jackrabbit.oak.commons.IOUtils.readFully(IOUtils.java:53)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor.getBlobKey(Compactor.java:412)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor.compact(Compactor.java:362)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor.compact(Compactor.java:321)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor.access$500(Compactor.java:54)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.propertyAdded(Compactor.java:227)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.CancelableDiff.propertyAdded(CancelableDiff.java:47)`<br><br>`at org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.compareAgainstEmptyState(EmptyNodeState.java:156)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:434)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.` `diff` `(Compactor.java:214)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.childNodeAdded(Compactor.java:263)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.CancelableDiff.childNodeAdded(CancelableDiff.java:74)`<br><br>`at org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.compareAgainstEmptyState(EmptyNodeState.java:161)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:434)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.` `diff` `(Compactor.java:214)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.childNodeAdded(Compactor.java:263)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.CancelableDiff.childNodeAdded(CancelableDiff.java:74)`<br><br>`at org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.compareAgainstEmptyState(EmptyNodeState.java:161)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:434)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.` `diff` `(Compactor.java:214)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.childNodeAdded(Compactor.java:263)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.CancelableDiff.childNodeAdded(CancelableDiff.java:74)`<br><br>`at org.apache.jackrabbit.oak.plugins.memory.EmptyNodeState.compareAgainstEmptyState(EmptyNodeState.java:161)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.SegmentNodeState.compareAgainstBaseState(SegmentNodeState.java:434)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.` `diff` `(Compactor.java:214)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.Compactor$CompactDiff.childNodeAdded(Compactor.java:263)`<br><br>`at org.apache.jackrabbit.oak.plugins.segment.CancelableDiff.childNodeAdded(CancelableDiff.java:74)` |
| --- |


<b>原因</b>

当压缩尝试读取节点时，区段不存在时，会返回SegmentNotFoundException。 原因可能有不同：

1. 已通过手动干预（如rm -rf /）删除该区段。
2. 该区段已通过修订垃圾收集删除。
3. 由于代码中存在某些错误，无法找到该区段。


如果问题是由修订垃圾收集（第2点）引起的，请确保禁用联机压缩以避免进一步的节点损坏。


## 分辨率


我们可以按照多个步骤来解决此问题，并成功完成离线压缩。

*重要信息：* 在执行以下步骤之前，对您的存储库执行完整备份。



<b>A.还原到区段存储的最后一个已知良好修订版本。</b>

oak-run的检查运行模式可用于确定区段存储的最后一个已知良好版本。 可用于手动将损坏的区段存储还原到其最新良好修订版。

*注意：<b>* </b>此过程会将系统中的数据回滚到以前的时间点。  如果您希望避免丢失系统中的更改，则可以尝试下面的选项B。

要执行检查和恢复，请执行以下操作：

1. 从此处下载oak-run jar文件 [http://repo1.maven.org/maven2/org/apache/jackrabbit/oak-run/](http://repo1.maven.org/maven2/org/apache/jackrabbit/oak-run/)
2. 停止AEM。
3. 运行以下命令：

   `java -jar oak-run-*.jar check --bin=-1 crx-quickstart/repository/segmentstore/`



   此命令在修订版本中向后搜索，直到找到一致的修订版本：

   `14:00:30.783 main INFO  o.a.j.o.p.s.f.t.ConsistencyChecker - Found latest good revision afdb922d-ba53-4a1b-aa1b-1cb044b535cf:234880`



   （如果ConsistencyChecker失败，请转到下一节）


4. 通过编辑将存储库还原到此修订版本。

   `/crx-quickstart/repository/segmentstore/journal.log.`



   删除包含最新良好修订的行之后的所有行。 如果要了解要将存储库还原到的日期和时间，请在segmentstore文件夹中运行此命令（将afdb922d-ba53-4a1b-aa1b-1cb044b535cf替换为journal.log中的最新良好修订）：

   `find . -type f -name "data*.tar" -exec sh -c "tar -tvf {} |grep afdb922d-ba53-4a1b-aa1b-1cb044b535cf" \; -print`



   输出将显示该修订的大致日期和时间。


5. 全部删除 `./crx-quickstart/repository/segmentstore/*.bak files.`
6. 如果使用AEM6.0，请下载与AEM中安装的版本相匹配的oak-run版本，以完成其余步骤。  从此处下载 [http://repo1.maven.org/maven2/org/apache/jackrabbit/oak-run/](http://repo1.maven.org/maven2/org/apache/jackrabbit/oak-run/).
7. 运行检查点清理以删除孤立的检查点：

   `java -jar oak-run-*.jar checkpoints ./crx-quickstart/repository/segmentstore rm-unreferenced.`


8. 最后，压缩存储库：

   `java -jar oak-run-*.jar compact ./crx-quickstart/repository/segmentstore/`




<b>B.手动删除损坏的节点。</b>

在AEM中，TarMK设置未配置FileDatastore，并且二进制文件中存在损坏的情况下，您可以执行以下操作。

*注意：*以下步骤适用于高级用户。  删除损坏的节点时，您需要确保它们不是系统节点（如/home、/jcr:system等）。  或者，如果它们是系统节点，则需要确保可以恢复它们。  如果您不确定，请咨询AEM客户关怀团队，以获取有关此处所述步骤的帮助。

1. 停止AEM。
2. 使用Oak运行控制台并加载childCount groovy脚本，以识别区段存储中损坏的节点：

   加载oak-run控制台Shell:

   `java -jar oak-run-*.jar console crx-quickstart/repository/segmentstore`



   在shell中运行以下两个命令以加载脚本并运行它：

   `:load`

   `https://gist.githubusercontent.com/stillalex/e7067bcb86c89bef66c8/raw/d7a5a9b839c3bb0ae5840252022f871fd38374d3/childCount.groovy`

   `countNodes(session.workingNode)`



   这会导致以下输出，指示损坏节点的路径：

   `21:21:42.029 main ERROR o.a.j.o.p.segment.SegmentTracker - Segment not found: 63ae05a4-b506-445c-baa2-cfa1b13b6e2f. Creation date delta is 3 ms.`

   `warning unable to read node /content/dam/test.txt/jcr:content/renditions/original/jcr:content`



   在某些情况下，问题已链接到二进制属性，并且childCount groovy脚本无法找到任何损坏的节点。  在这些情况下，您可以改用以下命令，该命令将读取遍历期间遇到的每个二进制文件的前1024个字节（请注意，此命令将变慢，仅当上述命令未返回预期结果时才使用）：

   `countNodes(session.workingNode,true)`


3. 使用rmNodes.groovy删除最后一个命令输出中列出的所有已识别的损坏节点

   加载oak-run控制台Shell:

   `java -jar oak-run-*.jar console crx-quickstart/repository/segmentstore`



   加载groovy脚本：

   `:load`

   `https://gist.githubusercontent.com/stillalex/43c49af065e3dd1fd5bf/raw/9e726a59f75b46e7b474f7ac763b0888d5a3f0c3/rmNode.groovy`



   运行rmNode命令以删除损坏的节点，将/path/to/corrupt/node替换为您需要删除的损坏节点的路径。

   `rmNode(session, "/path/to/corrupt/node")`



   其中损坏的节点路径是在步骤2中获取的路径，例如： `"/content/dam/test.txt/jcr:content/renditions/original/jcr:content/"`
注意：在使用oak-run.jar版本1.6.13及更高版本时，如果遇到以下错误，请设置 — 读写JVM参数：






   ```
   / rmNode(session,"/path/to/corrupt/node")    Removing node /path/to/corrupt/node    ERROR java.lang.UnsupportedOperationException:    Cannot write to read-only store    at org.apache.jackrabbit.oak.segment.SegmentWriterBuilder$1.execute (SegmentWriterBuilder.java:171)    at org.apache.jackrabbit.oak.segment.SegmentWriter.writeNode (SegmentWriter.java:318)    at org.apache.jackrabbit.oak.segment.SegmentNodeBuilder.getNodeState (SegmentNodeBuilder.java:111)    at org.apache.jackrabbit.oak.segment.SegmentNodeStore$Commit.init (SegmentNodeStore.java:581)    at org.apache.jackrabbit.oak.segment.SegmentNodeStore.merge (SegmentNodeStore.java:333)    at org.apache.jackrabbit.oak.spi.state.NodeStore$merge.call (Unknown Source)    at groovysh_evaluate.rmNode (groovysh_evaluate:11)
   ```

4. 对步骤2中找到的所有节点重复步骤3。

   对于损坏的路径，上述rmNode命令应返回true，这表示该路径已删除。 通过在这些路径上重新运行rmNode命令，确保这些已发现的三个损坏的路径被删除。 下次运行时，应返回false。

   如果您仍然看到存储库中存在相同的路径，则请使用oak-run jar的修补版本，即oak-run-1.2.18-NPR-17596

   Oak run Jar的修补版本有何用途？

   此版本的jar会在压缩时将无法读取的二进制文件替换为0字节二进制文件，并记录异常和系统路径。 这样压缩的存储库应该通过oak-run检查、节点计数脚本，并且您还应该能够使用未修补的oak-run再次压缩它。


5. 通过使用以下方法列出检查点来执行检查点清理。 如果有多个检查点，则清除它们：

   `nohup java -Xmx4096m -jar oak-run-1.2.18.jar checkpoints /app/AEM6/author/crx-quickstart/repository/segmentstore rm-allnohup.out &`
6. 运行离线压缩。  如果您不知道如何运行离线压缩，请参阅 [此处](https://gist.github.com/andrewmkhoury/0b1fe4d8b619178ff87b).
7. 启动服务器，等待索引完成。
