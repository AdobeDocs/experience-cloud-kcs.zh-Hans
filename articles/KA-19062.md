---
title: 如何在AEM 6.x中报告问题时调试SegmentNotFoundException
description: 描述
solution: Experience Manager
product: Experience Manager
applies-to: Experience Manager
keywords: KCS
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Akash Kapoor
article-created-date: 4/3/2022 7:14:43 PM
article-published-by: Akash Kapoor
article-published-date: 4/3/2022 7:14:58 PM
version-number: 4
article-number: KA-19062
dynamics-url: https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=63dd174c-82b3-ec11-983f-000d3a5d09d6
exl-id: 0580f08b-a72c-45ec-817e-e850d2360e9d
source-git-commit: e8f4ca2dd578944d4fe399074fab461de88ad247
workflow-type: tm+mt
source-wordcount: '1214'
ht-degree: 0%

---

# 如何在AEM 6.x中报告问题时调试SegmentNotFoundException

## 描述


<b>如何在AEM 6.x中报告问题时调试SegmentNotFoundException</b>

A <b>SegmentNotFoundException</b> 在错误日志中，表示某个区段不再存在，尽管某人显然仍尝试访问该区段。 造成这种情况的原因大致有三个：区段已通过手动干预（例如rm -rf /）删除，区段已通过修订垃圾收集删除，或者由于代码中存在某些错误而找不到区段。

日志中可能会出现以下异常：

...

org.apache.jackrabbit.oak.segment.segmentNotFoundException:区段d2c720c4-c146-4ab1-ac37-542aad93c33f在org.apache.jackrabbit.oak.segment.file.FileStore$8.call(FileStore.java:602),at org.apache.jackrabbit.oak.segment.file.FileStore$8.call(FileStore.java:542)at.org.org.abit.getGetSegmentGegetSegmentSegmentSegmentGegemementsegmentCache.java:95)(位于org.apache.jackrabbit.oak.segment.file.FileStore.readSegment(FileStore.java:542)，位于org.apache.jackrabbit.oak.segment.getSegment(SegmentId.java:125)，位于org.apache.jackrabbit.segment.getSegment(Record.java:70)org.apache.ap.mapRecoark.mapRecorkRecorop.mapRedRecororokRedMap.map(RecordRecororRecordMap.RecordRecorord.Reg4在org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:433)的org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:391)的org.apache.jackrabbit.segment.segmentNodeState.compareFBaseState(SegmentNodeJava:608)at.org.ache.commit.javedif.jor.corbit.cheditCordCordCordCor(CordCorCordCorCordCordCordNedCord(Cordild.java:148)(org.apache.jackrabbit.oak.segment.MapRecord$3.childNodeChanged(MapRecord.java:442)(位于org.apache.jackrabbit.oak.segment.MapRecord.compare(MapRecord.java:490)at.apache.ach.segment.java:433)a.org.ok.segment.Oabate.seg.segmateSetStegmpateSateSateSateSate.comparegmpate(SegmentNodeState.java:608)在org.apache.jackrabbit.oak.spi.commit.EditorDiff.process(EditorDiff.java:52)，位于org.apache.jackrabbit.oak.plugins.index.AsyncIndexUpdate.updateIndex(AsyncIndexUpdage.java:695)，位于org.apache.jabat.ax.inde.aplude.runPlins(ApacheApacheInceIndeIndeIndeIndeIndex.Index.jave.Upde.a.java.Upde.a.a.jackrabbit.oak.plugins.index.AsyncIndexUpdate.run(AsyncIndexUpdate.java:402)，位于org.apache.sling.commons.scheduler.impl.QuartzJobExecutor.execute(QuartzJobJobExecutor.java:118)，位于org.quart.core.JobRunShell.run(Java:202)at.a.concurrent.Putil.PlTilPlPouter.Jor.JavaExecutor.runJavaJava(ExecorJavaJavaJavaExecutor.r(JavaJavaJavaJava111JavaExecor:Jav42)java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617),java.lang.Thread.run(Thread.java:745)

...


## 分辨率


我们可以遵循以下两种方法来解决此问题，并删除下面A和B节中所述的存储库中的不一致问题。

<b>A.还原到区段存储的最后一个已知良好修订版本。</b>

首先，我们需要使用oak运行工具，该工具是一个可运行的jar1，其中包含您进行简单的Oak安装和执行与oak相关的操作所需的一切功能。

oak-run的检查运行模式可用于确定区段存储的最后一个已知良好版本。  可用于手动将损坏的区段存储还原到其最新良好修订版。

*注意：此过程会将系统中的数据回滚到上一个时间点。  如果您希望避免丢失系统中的更改，则可以尝试下面的选项B。*

要执行检查和恢复，请执行以下操作：

1. 从下载与Oak核心版本匹配的oak-run版本 [https://mvnrepository.com/artifact/org.apache.jackrabbit/oak-run](https://mvnrepository.com/artifact/org.apache.jackrabbit/oak-run)
2. 要将损坏的区段存储还原到其最新的良好状态更改，请还原到CQ的工作目录（包含crx-quickstartfolder的目录）中，并备份中的所有文件。/crx-quickstart/repository/segmentstore/.
3. 运行一致性检查java -Xmx6000m -jar oak-run-\*.jar检查 — bin=-1 /path/to/crx-quickstart/repository/segmentstore在修订版本中向后搜索，直到找到一致的版本：查找如下消息：主要信息o.a.j.o.p.s.f.t.ConsistencyChecker — 找到最新的良好修订版afdb922d-ba53-4a1b-aa1b-1cb044b535cf:234880
4. 通过编辑将存储库还原到此修订版本。/crx-quickstart/repository/segmentstore/journal.log ，并删除包含最新良好修订版本的行之后的所有行。
5. 全部删除。/crx-quickstart/repository/segmentstore/\*.bak文件。
6. 通过以下命令运行检查点清理以删除孤立检查点：java -Xmx6000m -jar oak-run-\*.jar检查点/path/to/crx-quickstart/repository/segmentstore rm-unreferenced
7. 最后，压缩存储库：java -Xmx6000m -jar oak-run-\*.jar compact /path/to/crx-quickstart/repository/segmentstore/




*有时，oak运行检查无法找到正确的修订版本，在运行check命令时，我们会收到“ConsistencyChecker — 未找到正确的修订版本”。*
<b>如何在一致性检查中遇到“ConsistencyChecker — 未找到良好的修订版”时修复损坏</b>


<b>B.手动删除损坏的节点。</b>

在AEM中，TarMK设置未配置FileDatastore，并且二进制文件中存在损坏的情况下，您可以执行以下操作。

\*注意n:\*以下过程适用于高级用户。  删除损坏的节点时，您需要确保它们不是系统节点（如/home、/jcr:system等）。  或者，如果它们是系统节点，则需要确保可以恢复它们。  如果您不确定，请咨询AEM客户关怀团队，以获取有关此处所述步骤的帮助。



1. 停止AEM。
2. 使用Oak运行控制台并加载childCount groovy脚本，以识别区段存储中损坏的节点：


加载oak-run控制台Shell:

java -jar oak-run-\*.jar控制台crx-quickstart/repository/segmentstore

在shell中运行以下两个命令以加载脚本并运行它：

:load https://gist.githubusercontent.com/stillalex/e7067bcb86c89bef66c8/raw/d7a5a9b839c3bb0ae5840252022f871fd38374d3/childCount.groovy

countNodes(session.workingNode)

这会导致以下输出，指示损坏节点的路径：

21:21:42.029主错误o.a.j.o.p.segment.SegmentTracker — 未找到区段：63ae05a4-b506-445c-baa2-cfa1b13b6e2f。 创建日期增量为3毫秒。

警告无法读取节点/content/dam/test.txt/jcr:content/renditions/original/jcr:content

在某些情况下，问题已链接到二进制属性，并且childCount groovy脚本无法找到任何损坏的节点。  在这些情况下，您可以改用以下命令，该命令将读取遍历期间遇到的每个二进制文件的前1024个字节（请注意，此命令将变慢，仅当上述命令未返回预期结果时才使用）：

countNodes(session.workingNode，true)

3. 使用rmNodes.groovy删除最后一个命令输出中列出的所有已识别的损坏节点

使用以下命令加载oak-run控制台外壳程序：

java -jar oak-run-\*.jar控制台crx-quickstart/repository/segmentstore

加载groovy脚本：

:load

https://gist.githubusercontent.com/stillalex/43c49af065e3dd1fd5bf/raw/9e726a59f75b46e7b474f7ac763b0888d5a3f0c3/rmNode.groovy

运行rmNode命令以删除损坏的节点，将/path/to/corrupt/node替换为您需要删除的损坏节点的路径。

rmNode(session， &quot;/path/to/corrupt/node&quot;)

其中损坏的节点路径是在步骤2中获取的路径，例如：&quot;/content/dam/test.txt/jcr:content/renditions/original/jcr:content/&quot;注意：在使用oak-run.jar版本1.6.13及更高版本时，如果遇到以下错误，请设置 — 读写JVM参数：

/ rmNode(session，&quot;/path/to/corrupt/node&quot;)正在删除节点/path/to/corrupt/node错误java.lang.UnsupportedOperationException:   无法写入org.apache.jackrabbit.oak.segment.SegmentWriterBuilder$1.execute(SegmentWriterBuilder.java:171)org.apache.jackrabbit.oak.segment.SegmentWriter.writeNode(SegmentWriter.java:318)的只读存储区(SegmentNodeBilder.java.java.segetNodeSegment.org.segegegement.segegegement.segmentSegement.org.odegetState(NodeNodeNodeNodeNegeg.odNeg.odegement.org.javeB.javeB.javeBuilderg在org.apache.jackrabbit.oak.segment.SegmentNodeStore.merge(SegmentNodeStore.java:333)的org.apache.jackrabbit.oak.spi.state.NodeStore$merge.call（未知源）的groovysh_evaluate.rmNode(groovh_evaluate:11)

4. 对步骤2中找到的所有节点重复步骤3。

对于损坏的路径，上述rmNode命令应返回true，这表示该路径已删除。 通过在这些路径上重新运行rmNode命令，确保这些已发现的三个损坏的路径被删除。 下次运行时，应返回false。

如果您仍然看到存储库中存在相同的路径，则请使用oak-run jar的修补版本，即oak-run-1.2.18-NPR-17596

Oak run Jar的修补版本有何用途？

此版本的jar会在压缩时将无法读取的二进制文件替换为0字节二进制文件，并记录异常和系统路径。 这样压缩的存储库应该通过oak-run检查、节点计数脚本，并且您还应该能够使用未修补的oak-run再次压缩它。

5. 通过使用以下方法列出检查点来执行检查点清理。 如果有多个检查点，则清除它们：

nohup java -Xmx4096m -jar oak-run-1.2.18.jar检查点/app/AEM6/author/crx-quickstart/repository/segmentstore rm-allnohup.out和

6. 运行离线压缩。  如果您不知道如何运行离线压缩，请参阅 [此处](https://gist.github.com/andrewmkhoury/0b1fe4d8b619178ff87b).

7. 启动服务器，等待索引完成。
