---
title: “了解缓存目录”
description: “了解如何在Adobe Experience Manager中执行Dispatcher缓存以及如何对其进行配置。”
solution: Experience Manager
product: Experience Manager
applies-to: "Experience Manager"
keywords: “KCS，了解缓存目录、AEM、Adobe Experience Manager、最佳实践”
resolution: Resolution
internal-notes: null
bug: false
article-created-by: Oleksandra Marchenko
article-created-date: "1/18/2024 3:39:17 PM"
article-published-by: Oleksandra Marchenko
article-published-date: "1/18/2024 3:44:47 PM"
version-number: 9
article-number: KA-17912
dynamics-url: "https://adobe-ent.crm.dynamics.com/main.aspx?forceUCI=1&pagetype=entityrecord&etn=knowledgearticle&id=063c58b9-17b6-ee11-a569-6045bd006a22"
source-git-commit: 56cc56c649cc946c55a99e24ed8f27165db207e3
workflow-type: tm+mt
source-wordcount: '1533'
ht-degree: 0%

---

# 了解缓存目录


本文档说明如何进行Dispatcher缓存以及如何对其进行配置。

## 描述 {#description}


<b>环境</b>
Adobe Experience Manager

<b>问题/症状</b>
本文档说明如何进行Dispatcher缓存以及如何对其进行配置。
[目录](https://experienceleague.adobe.com/docs/experience-cloud-kcs/kbarticles/KA-17490.html)

## 解决方法 {#resolution}


<b>缓存目录</b>

我们在基线安装中使用以下默认缓存目录

- 作者

   - /mnt/var/www/author
- 发布者

   - /mnt/var/www/html


当每个请求遍历调度程序时，请求遵循配置的规则以保留符合条件的项目响应的本地缓存版本。

<b>注意：</b>

我们刻意将已发布的工作负载与创作工作负载分开，因为当Apache在DocumentRoot中查找文件时，它不知道该文件来自哪个AEM实例。 因此，即使您在创作场中禁用了缓存，但如果作者的DocumentRoot与发布者相同，则它将在存在时从缓存中提供文件。 这意味着您将从已发布的缓存中提供创作文件，并为访客创造非常糟糕的混合匹配体验。 为不同的已发布内容保留单独的DocumentRoot目录也是个非常糟糕的主意。 您必须创建多个在clientlibs等站点之间没有差异的重新缓存项目，还必须为您设置的每个DocumentRoot设置复制刷新代理，这会增加每次页面激活的刷新开销。 依赖文件的命名空间及其完全缓存的路径，并避免为已发布的站点使用多个DocumentRoot。



<b>配置文件</b>

Dispatcher控制在任何场文件的/cache部分中限定为可缓存的内容。 
在AMS基线配置场中，您会发现包含的，如下所示：


```
/cache { 
    /rules { 
        $include "/etc/httpd/conf.dispatcher.d/cache/ams_author_cache.any" 
    }
```


在创建缓存或不缓存内容的规则时，请参阅文档 [此处](https://experienceleague.adobe.com/docs/experience-manager-dispatcher/using/configuring/dispatcher-configuration.html?lang=en#configuring-the-dispatcher-cache-cache)



<b>缓存作者</b>

我们已经看到有许多实施中的用户不缓存创作内容。 
他们在性能和对作者的响应能力方面错过了巨大的提升。

让我们讨论在配置创作场以正确缓存时采取的策略。

以下是作者场文件的基本作者/cache部分：


```
/cache { 
    /docroot "/mnt/var/www/author" 
    /statfileslevel "2" 
    /allowAuthorized "1" 
    /rules { 
        $include "/etc/httpd/conf.dispatcher.d/cache/ams_author_cache.any" 
    } 
    /invalidate { 
        /0000 { 
            /glob "*" 
            /type "allow" 
        } 
    } 
    /allowedClients { 
        /0000 { 
            /glob "*.*.*.*" 
            /type "deny" 
        } 
        $include "/etc/httpd/conf.dispatcher.d/cache/ams_author_invalidate_allowed.any" 
    } 
}
```


这里要注意的重要事项是 <b>/docroot</b> 设置为作者的缓存目录。

<b>注意：</b>

确保您在作者的.vhost文件中的DocumentRoot与场/docroot参数匹配。

缓存规则include语句包含文件 <b>/etc/httpd/conf.dispatcher.d/cache/ams_author_cache.any</b> ，其中包含下列规则：


```
/0000 { 
 /glob "*" 
 /type "deny" 
} 
/0001 { 
 /glob "/libs/*" 
 /type "allow" 
} 
/0002 { 
 /glob "/libs/*.html" 
 /type "deny" 
} 
/0003 { 
 /glob "/libs/granite/csrf/token.json" 
 /type "deny" 
} 
/0004 { 
 /glob "/apps/*" 
 /type "allow" 
} 
/0005 { 
 /glob "/apps/*.html" 
 /type "deny" 
} 
/0006 { 
 /glob "/libs/cq/core/content/welcome.*" 
 /type "deny" 
}
```


在创作场景中，内容会随时随意更改。 您只想缓存不经常更改的项目。
我们有缓存/libs的规则，因为它们是基准AEM安装的一部分，在安装Service Pack、累积修补程序包、升级或修补程序之前可能会发生更改。 缓存这些元素不仅意义重大，而且真正有益于使用该站点的最终用户的创作体验。

<b>注意：</b>

请记住，这些规则也会缓存 <b>/apps</b> 这是自定义应用程序代码所在的位置。 如果您在此实例上开发代码，则在保存文件时会发现非常混乱，并且不会看到它是否反映在UI中，因为它提供缓存的副本。 这样做的目的是，如果您将代码部署到AEM中，那么这种部署也不频繁，并且部署步骤的一部分应该是清除创作缓存。 同样，其优势也是巨大的，可使您的可缓存代码能够为最终用户更快地运行。



<b>ServeOnStale（又称陈旧/SOS服务）</b>

这是Dispatcher的一项功能带来的好处之一。 如果发布者负载不足或变得无响应，则通常会引发502或503 http响应代码。 如果发生这种情况并启用了此功能，作为最大努力，将指示Dispatcher仍然提供缓存中任何仍存在的内容，即使它不是新副本也是如此。 如果您已获得某些内容，则最好提供该内容，而不是只显示一条不提供任何功能的错误消息。

<b>注意：</b>

请记住，如果发布者渲染器具有套接字超时或500错误消息，则不会触发此功能。 如果AEM不可访问，则此功能不执行任何操作。

可以在任何场上设置此设置，但将其应用于已发布的场文件才是合理的。 以下是场文件中启用的功能的语法示例：


```
/cache { 
    /serveStaleOnError "1"
```




<b>使用查询参数/参数缓存页面</b>

<b>注意：</b>

Dispatcher模块的正常行为之一是，如果请求在URI中有查询参数(通常显示为/content/page.html<b>？myquery=value</b>)它将跳过文件缓存，直接转到AEM实例。 它将此请求视为动态页面，不应缓存。 这可能会对缓存效率产生不良影响。

如果您在AEM中的页面在地址行中采用GET参数/查询参数来帮助页面操作，但不呈现不同的HTML，则适合此配置元素。

您可以告知Dispatcher要忽略并且仍缓存页面的参数。

例如，有人建立了一个社交媒体深层链接引用机制，它使用URI中的参数引用来了解此人来自何处。

<b>用法示例：</b>

[https://www.retail.com/home.html?reference=android](https://www.retail.com/home.html?reference=android)

[https://www.retail.com/home.html?reference=facebook](https://www.retail.com/home.html?reference=facebook)

该页面是100%可缓存的，但由于参数存在而不进行缓存。 
要解决此问题，我们在场配置文件中添加以下部分：


```
/cache { 
    /ignoreUrlParams { 
        /0001 { /glob "*" /type "deny" } 
        /0002 { /glob "reference" /type "allow" } 
    }
```


现在，当Dispatcher看到请求时，它会忽略该请求具有引用的查询参数并且仍缓存页面这一事实。



<b>缓存响应标头</b>

很明显，Dispatcher可以缓存.html页面和clientlibs，但是您知道它还可以将特定的响应标头与内容一起缓存到扩展名为.h但名称相同的文件中？ 这样不仅可以对内容进行下一个响应，还可以对缓存中应随其一起使用的响应标头进行响应。

AEM可以处理的不只是UTF-8编码。

有时，项目具有特殊的标头，可帮助控制缓存TTL的编码详细信息和上次修改的时间戳。

默认情况下，这些值在缓存后会被清除，apache httpd Web服务器将使用其常规文件处理方法来自行处理资产，这通常仅限于根据文件扩展名进行mime类型推测。

如果您让Dispatcher缓存资产和所需的标头，则可以公开适当的体验，并确保将所有详细信息提供给客户端的浏览器。

以下是场示例，其中指定了要缓存的标头：


```
/cache { 
 /headers { 
  "Cache-Control" 
  "Content-Disposition" 
  "Content-Type" 
  "Expires" 
  "Last-Modified" 
  "X-Content-Type-Options" 
 } 
}
```


在本例中，他们已将AEM配置为提供CDN查找以确定何时使其缓存失效的标头。 这意味着现在AEM可以正确规定哪些文件将根据标头失效。

<b>注意：</b>

请记住，您不能使用正则表达式或glob匹配。 它是要缓存的标头的文字列表。 仅放入要缓存的文本标头的列表中。



<b>自动使宽限期失效</b>

如果作者的AEM系统执行大量页面激活操作，您可能会遇到反复出现无效情况的竞争条件。 无需频繁重复的刷新请求，您可以构建某种容差，以在宽限期清除之前不重复刷新。

<b>其工作原理示例：</b>

如果您有五个使/content/exampleco/en/失效的请求，则所有这些请求都会在3秒内发生。

关闭此功能后，您将使缓存目录/content/exampleco/en/失效5次。

启用此功能并将其设置为5秒后，将会使缓存目录/content/exampleco/en/once失效。

以下是为5秒宽限期配置的此功能的语法示例：


```
/cache { 
    /gracePeriod "5"
```




<b>基于TTL的失效</b>

Dispatcher模块的新增功能是 <b>生存时间(TTL)</b> 基于缓存项目的失效选项。 当缓存项目时，它会查找是否存在缓存控制标头，并在缓存目录中生成一个具有相同名称和 <b>.ttl</b> 扩展。

以下是场配置文件中配置的功能示例：


```
/cache { 
    /enableTTL "1"
```


<b>注意：</b>

请记住，仍需要将AEM配置为发送TTL标头，以便Dispatcher遵循这些标头。 切换此功能只会让Dispatcher知道何时移除AEM已发送缓存控制标头的文件。 如果AEM未开始发送TTL标头，则Dispatcher不会在此处执行任何特殊的操作。



<b>缓存筛选规则</b>

以下是要在发布服务器上缓存其元素的基线配置示例：


```
/cache{ 
    /0000 { 
        /glob "*" 
        /type "allow" 
    } 
    /0001 { 
        /glob "/libs/granite/csrf/token.json" 
        /type "deny" 
    }
```


我们希望使已发布的网站尽可能贪婪，并缓存所有内容。

如果存在在缓存时破坏体验的元素，则可以添加规则以删除用于缓存该项目的选项。 如上面的示例所示，不应缓存csrf令牌并将其排除。 有关编写这些规则的更多详细信息，请参阅 [此处](https://experienceleague.adobe.com/docs/experience-manager-dispatcher/using/configuring/dispatcher-configuration.html?lang=en#configuring-the-dispatcher-cache-cache).
